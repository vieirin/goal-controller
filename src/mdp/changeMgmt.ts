import { groupBy } from 'lodash';
import { GoalNode, GoalTree } from '../ObjectiveTree/types';
import { goalRootId, leafGoals } from '../ObjectiveTree/utils';

const leavesGrouppedGoals = ({ gm }: { gm: GoalTree }) =>
  groupBy(leafGoals({ gm }), goalRootId);

export const goalVariables = ({ gm }: { gm: GoalTree }) => {
  const goalGroups = leavesGrouppedGoals({ gm });
  const variableLines = Object.entries(goalGroups).map(([goal, variants]) => {
    return variants
      .map((variant) => [
        `${variant.id}_achievable: bool init true;`,
        `${variant.id}_achieved: bool init false;`,
      ])
      .map((elem) => elem.map((line) => `  ${line}`));
  });

  const grouppedVariableLines = variableLines.map((line) =>
    groupBy(line.flat(), (l) => l.includes('achievable'))
  );

  return grouppedVariableLines
    .map((grouppedLine) =>
      Object.values(grouppedLine)
        .map((elem) => elem)
        .flat()
    )
    .map((line) => line.join('\n'))
    .join('\n\n');
};

const alphabet = 'abcdefghijklmnopqrstuvwxyz';
const outcomePrefix = ({ step }: { step: number }) =>
  `  [] !t & !fail & step=${step} &`;

// note: we can verify `transitionSentence` by using an antlr grammar to make sure the syntax is correct
// it might not be necessary as the code is autogenerated, BUT it can prevent changes in the future that
// can cause the sentence to be invalid
const outcomeLineTemplate = ({
  transitionSentence,
  step,
}: {
  step: number;
  transitionSentence: string;
}) => `${outcomePrefix({ step })} ${transitionSentence}`;

const templateGoalOutcome = ({
  goalId,
  transitionSentences,
  step,
}: {
  goalId: string;
  transitionSentences: string[];
  step: number;
}) => `  // outcomes of pursuing goal ${goalId}
${transitionSentences
  .map((sentence) =>
    outcomeLineTemplate({ step, transitionSentence: sentence })
  )
  .join('\n')}`;

export const outcomes = ({ gm }: { gm: GoalTree }) => {
  const goalGroups = leavesGrouppedGoals({ gm });

  let step = 0;
  return Object.entries(goalGroups)
    .map(([goalId, goals]) => {
      const variants = goals.filter((goal) => !!goal.variantOf);
      const nonVariantGoal = goals.filter((goal) => !goal.variantOf);
      const innerStep = step;
      step++;

      const hasVariants = variants.length;
      const nextStep = innerStep + 1;
      const initialSentence = `${goalId}_pursued=0 -> 1:(step'=${nextStep});`;

      if (hasVariants) {
        if (!nonVariantGoal.length) {
          const goalsWithVariantsAtTheEnd = [...variants];

          const transitionSentences = [
            initialSentence,
            ...goalsWithVariantsAtTheEnd.map((goal, i) => {
              const [id, subId] = [...goal.id.slice(-2)];
              const subIdNumber = alphabet.indexOf(subId) + 1;
              const pVar = `p${id}_${subIdNumber}`;
              return `${goalId}_pursued=${i + 1} -> ${pVar}:(${
                goal.id
              }_achieved'=true)&(step'=${nextStep}) + (1-${pVar}):(${
                goal.id
              }_achievable'=false)&(fail'=true)&(step'=${nextStep});`;
            }),
          ];

          return templateGoalOutcome({
            goalId,
            transitionSentences,
            step: innerStep,
          });
        } else {
          throw new Error(
            `Goal (${goalId}) has variants and non variants goals groupped, invalid syntax, check the following goals: (${goals.map(
              (id) => id
            )})`
          );
        }
      }

      if (!hasVariants && goals.length === 1) {
        const pVar = `p${goalId.slice(-1)}`;

        const transitionSentences = [
          initialSentence,
          `${goalId}_pursued>0 -> ${pVar}:(${goalId}_achieved'=true)&(step'=${nextStep}) + (1-${pVar}):(${goalId}_achievable'=false)&(fail'=true)&(step'=${nextStep});`,
        ];

        return templateGoalOutcome({
          goalId,
          transitionSentences,
          step: innerStep,
        });
      } else {
        throw new Error(
          `Goal variable should be a leaf, got (${goals
            .map((id) => id)
            .join(',')}) as non-variant goals for (${goalId})`
        );
      }
    })
    .join('\n\n');
};

export const lastStep = ({ gm }: { gm: GoalTree }) => {
  const goalGroups = leavesGrouppedGoals({ gm });
  return Object.keys(goalGroups).length - 1;
};
