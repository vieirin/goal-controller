// ======================================================
// Basic sanity / reachability
// ======================================================

// Probability that the top-level goal G0 is eventually achieved
P=?  [ F G0_achieved=1 ];

// Probability that we eventually reach a state where both inFlight and commLink hold
// (i.e., the maintain goal G7 is actually realized at least once)
P=?  [ F (inFlight & commLink) ];


// ======================================================
// Sequential AND semantics
//   - G0: [G1; G2; G3; G4; G5]
//   - G14: [T10; T11]
// ======================================================

// --- G0: later subgoals are only pursued once previous ones are achieved ---

// G2 is only pursued after G1 is achieved
P>=1 [ G (G2_pursued=1 => G1_achieved=1) ];

// G3 is only pursued after G1 and G2 are achieved
P>=1 [ G (G3_pursued=1 => (G1_achieved=1 & G2_achieved=1)) ];

// G4 is only pursued after G1, G2 and G3 are achieved
P>=1 [ G (G4_pursued=1 => (G1_achieved=1 & G2_achieved=1 & G3_achieved=1)) ];

// G5 is only pursued after G1, G2, G3 and G4 are achieved
P>=1 [ G (G5_pursued=1 => (G1_achieved=1 & G2_achieved=1 & G3_achieved=1 & G4_achieved=1)) ];

// Optional: never pursue two top-level subgoals of G0 in parallel
P>=1 [ G !(
      (G1_pursued=1 & G2_pursued=1)
   |  (G2_pursued=1 & G3_pursued=1)
   |  (G3_pursued=1 & G4_pursued=1)
   |  (G4_pursued=1 & G5_pursued=1)
) ];

// --- G14: T10;T11 must be sequential ---

// T11 is only pursued after T10 has been achieved
P>=1 [ G (T11_pursued=1 => T10_achieved=1) ];

// Optional: T10 and T11 are not pursued in parallel
P>=1 [ G !(T10_pursued=1 & T11_pursued=1) ];


// ======================================================
// Interleaved AND semantics
//   - G1: [T1 # T2]
//   - G2: [G6 # G7]
// ======================================================

// --- G1: both T1 and T2 needed, order not fixed ---

// It is possible to pursue T1 first (before T2)
P>0  [ F (G1_pursued=1 & T1_pursued=1 & T2_pursued=0) ];

// It is possible to pursue T2 first (before T1)
P>0  [ F (G1_pursued=1 & T2_pursued=1 & T1_pursued=0) ];

// While G1 is active, at least one of T1 or T2 is being pursued
P>=1 [ G ((G1_pursued=1 & G1_achieved=0) 
          => (T1_pursued=1 | T2_pursued=1)) ];


// --- G2: G6 and G7 are interleaved children ---

// It is possible to pursue G6 while G7 is not yet pursued
P>0  [ F (G2_pursued=1 & G6_pursued=1 & G7_pursued=0) ];

// It is possible to pursue G7 while G6 is not yet pursued
P>0  [ F (G2_pursued=1 & G7_pursued=1 & G6_pursued=0) ];

// While G2 is active, at least one of G6 or G7 is being pursued
P>=1 [ G ((G2_pursued=1 & G2_achieved=0)
          => (G6_pursued=1 | G7_pursued=1)) ];


// ======================================================
// Choice semantics for G3: Configure Flight Profile [+]
// Branches: G9, G10, G11
// ======================================================

// 1) Mutual exclusion: never pursue two profile goals in parallel
P>=1 [ G !(
      (G9_pursued=1 & G10_pursued=1)
   |  (G9_pursued=1 & G11_pursued=1)
   |  (G10_pursued=1 & G11_pursued=1)
) ];

// 2) Once G9 is being pursued and G3 is still active,
//    no other profile goal is pursued at the same time
P>=1 [ G ( (G3_pursued=1 & G3_achieved=0 & G9_pursued=1)
          => (G10_pursued=0 & G11_pursued=0) ) ];

// 3) Once G10 is being pursued and G3 is still active,
//    no other profile goal is pursued at the same time
P>=1 [ G ( (G3_pursued=1 & G3_achieved=0 & G10_pursued=1)
          => (G9_pursued=0 & G11_pursued=0) ) ];

// 4) Once G11 is being pursued and G3 is still active,
//    no other profile goal is pursued at the same time
P>=1 [ G ( (G3_pursued=1 & G3_achieved=0 & G11_pursued=1)
          => (G9_pursued=0 & G10_pursued=0) ) ];

// Each branch is actually reachable from the initial state
P>0  [ F (G3_pursued=1 & G9_pursued=1) ];
P>0  [ F (G3_pursued=1 & G10_pursued=1) ];
P>0  [ F (G3_pursued=1 & G11_pursued=1) ];


// ======================================================
// Degradation semantics
//   - G4: Maintain Safety Envelope [G12 @2 -> G13]
// ======================================================

// Degrade to G13 only after at least 2 failed attempts of G12
P>=1 [ G (G13_pursued=1 => G12_failed>=2) ];

// It is possible to succeed using only G12 (no degradation)
P>0  [ F (G4_achieved=1 & G12_achieved=1 & G13_achieved=0) ];

// It is possible to reach G4 by using the degraded mode G13
P>0  [ F (G4_achieved=1 & G13_achieved=1) ];


// ======================================================
// Alternative OR semantics
//   - G5: Standard Landing Delivery [G14 | G15]
// ======================================================

// The two landing options are not pursued in parallel
P>=1 [ G !(G14_pursued=1 & G15_pursued=1) ];

// It is possible to satisfy G5 via G14
P>0  [ F (G5_achieved=1 & G14_achieved=1) ];

// It is possible to satisfy G5 via G15
P>0  [ F (G5_achieved=1 & G15_achieved=1) ];


// ======================================================
// Maintain semantics
//   - G7: Maintain communication link
//     assertion: inFlight
//     maintain:  commLink
// ======================================================

// Structural: G7 is only pursued when the drone is in flight
P>=1 [ G (G7_pursued=1 => inFlight) ];

// Structural: G7's "achieved_maintain" condition matches commLink
P>=1 [ G ( (G7_achieved_maintain & commLink)
        | (!G7_achieved_maintain & !commLink) ) ];

// Maintain objective (1): once the drone climbs to cruise altitude (inFlight),
// we eventually reach a state where commLink is true while still inFlight
P>=1 [ F (inFlight & commLink) ];

// Maintain: if communication fails while in flight,
// there must exist SOME path that recovers link or leaves flight.
filter(forall,
       P>0 [ F (commLink | !inFlight) ],
       inFlight & !commLink);