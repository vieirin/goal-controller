//
// G0: top-level sequential AND over G1, G2, G3
//

// G0: G2 is never pursued before G1 is achieved
P>=1 [ G (G2_pursued=1 => G1_achieved=1) ];

// G0: G3 is never pursued before both G1 and G2 are achieved
P>=1 [ G (G3_pursued=1 => (G1_achieved=1 & G2_achieved=1)) ];

// G0: whenever G0 is achieved, G1, G2 and G3 are all achieved
P>=1 [ G (G0_achieved=1 => (G1_achieved=1 & G2_achieved=1 & G3_achieved=1)) ];


//
// G1: interleaved AND over T1 and T2 (parallel, no fixed order)
//

// G1: from a state where G1 is pursued, there is a non-zero probability
//     to eventually have both T1 and T2 pursued (some interleaving of both)
P>0 [ F (T1_pursued=1 & T2_pursued=1) ];

// G1: T1 can be pursued while T2 is not yet pursued (no enforced T2-before-T1 order)
P>0 [ F (G1_pursued=1 & T1_pursued=1 & T2_pursued=0) ];

// G1: T2 can be pursued while T1 is not yet pursued (no enforced T1-before-T2 order)
P>0 [ F (G1_pursued=1 & T2_pursued=1 & T1_pursued=0) ];


//
// G2: alternative branch between G4 and G5
//      "G2 chooses a given branch and proceeds with it"
//

// G2: G4 and G5 are never pursued at the same time (exclusive alternatives)
P>=1 [ G !(G4_pursued=1 & G5_pursued=1) ];

// G2: if the visual-avoidance branch (G4) is selected and G2 is still active,
//     then lidar branch tasks are not pursued (T5, T6 disabled while committed to G4)
P>=1 [ G ((G2_pursued=1 & (G4_pursued=1 | G4_achieved=1) & G2_achieved=0)
          => (G5_pursued=0 & T5_pursued=0 & T6_pursued=0)) ];

// G2: if the lidar-avoidance branch (G5) is selected and G2 is still active,
//     then visual branch tasks are not pursued (T3, T4 disabled while committed to G5)
P>=1 [ G ((G2_pursued=1 & (G5_pursued=1 | G5_achieved=1) & G2_achieved=0)
          => (G4_pursued=0 & T3_pursued=0 & T4_pursued=0)) ];


//
// G3: sequential AND over G6 then G7
//

// G3: G7 is never pursued before G6 is achieved (sequential order G6 -> G7)
P>=1 [ G (G7_pursued=1 => G6_achieved=1) ];

// G3: whenever G3 is achieved, both G6 and G7 are achieved
P>=1 [ G (G3_achieved=1 => (G6_achieved=1 & G7_achieved=1)) ];

// G3: once G3 is being pursued, G6 must be achieved before any pursuit of G7
P>=1 [ G (G3_pursued=1 => (!(G7_pursued=1) U (G6_achieved=1))) ];