//
// --------------------------------------------------------------
// G0: top-level – G1, then G2, then G3 (sequential refinement)
// --------------------------------------------------------------
// While G0 is pursued and G1 is not yet achieved, neither G2 nor G3 may be pursued
P>=1 [ G ( G0_pursued=1 & G1_achieved=0 => (G2_pursued=0 & G3_pursued=0) ) ];

// While G0 is pursued and G1 is achieved but G2 is not, G3 may not be pursued (G2 must come before G3)
P>=1 [ G ( G0_pursued=1 & G1_achieved=1 & G2_achieved=0 => G3_pursued=0 ) ];

// If G3 is pursued, then both G1 and G2 are already achieved (no skipping earlier goals)
P>=1 [ G ( G3_pursued=1 => (G1_achieved=1 & G2_achieved=1) ) ];

// Whenever G0 is achieved, all three children G1, G2 and G3 are already achieved (matches achieved_G0 guard)
P>=1 [ G ( G0_achieved=1 => (G1_achieved=1 & G2_achieved=1 & G3_achieved=1) ) ];


//
// --------------------------------------------------------------
// G1: sequence of T1 then T2
// --------------------------------------------------------------
// While G1 is pursued and T1 is not yet achieved, T2 cannot be pursued (T1 must precede T2)
P>=1 [ G ( G1_pursued=1 & T1_achieved=0 => T2_pursued=0 ) ];

// If T2 is achieved, then T1 must already be achieved (no completion of T2 without prior T1)
P>=1 [ G ( T2_achieved=1 => T1_achieved=1 ) ];

// When G1 is achieved, both T1 and T2 are achieved (consistency with achieved_G1 guard)
P>=1 [ G ( G1_achieved=1 => (T1_achieved=1 & T2_achieved=1) ) ];


//
// --------------------------------------------------------------
// G2: OR between G4 and G5 (can select either child, and re-decide in later steps)
// --------------------------------------------------------------
// At any time, G4 and G5 are not pursued simultaneously (one OR-child at a time)
P>=1 [ G !(G4_pursued=1 & G5_pursued=1) ];

// If G2 is achieved, then at least one of G4 or G5 has been achieved (matches achieved_G2 guard)
P>=1 [ G ( G2_achieved=1 => (G4_achieved=1 | G5_achieved=1) ) ];

// There exists a path where G4 is pursued at some point while G2 is being considered (G4 is a selectable child)
P>0 [ F (G4_pursued=1) ];

// There exists a path where G5 is pursued at some point while G2 is being considered (G5 is a selectable child)
P>0 [ F (G5_pursued=1) ];


//
// --------------------------------------------------------------
// G3: Deliver package via T5
// --------------------------------------------------------------
// When G3 is achieved, T5 is achieved (matches achieved_G3 guard)
P>=1 [ G ( G3_achieved=1 => T5_achieved=1 ) ];


//
// --------------------------------------------------------------
// Leaf goals G4 and G5 and their tasks T3 and T4
// --------------------------------------------------------------
// When G4 is achieved, T3 is achieved (matches achieved_G4 guard)
P>=1 [ G ( G4_achieved=1 => T3_achieved=1 ) ];

// When G5 is achieved, T4 is achieved (matches achieved_G5 guard)
P>=1 [ G ( G5_achieved=1 => T4_achieved=1 ) ];

//
// =============================================================
// COUNTEREXAMPLES: G0 SEQUENCE (G1 → G2 → G3)
// =============================================================

// (Bad) G2 is pursued before G1 is achieved
P>0 [ F ( G0_pursued=1 & G1_achieved=0 & G2_pursued=1 ) ];

// (Bad) G3 is pursued before G2 is achieved
P>0 [ F ( G0_pursued=1 & G2_achieved=0 & G3_pursued=1 ) ];

// (Bad) G3 is pursued before G1 is achieved
P>0 [ F ( G3_pursued=1 & G1_achieved=0 ) ];

// (Bad) G0 is achieved while a child goal is not achieved
P>0 [ F ( G0_achieved=1 & (G1_achieved=0 | G2_achieved=0 | G3_achieved=0) ) ];


//
// =============================================================
// COUNTEREXAMPLES: G1 SEQUENCE (T1 → T2)
// =============================================================

// (Bad) T2 is pursued before T1 is achieved
P>0 [ F ( G1_pursued=1 & T1_achieved=0 & T2_pursued=1 ) ];

// (Bad) T2 is achieved while T1 is not achieved
P>0 [ F ( T2_achieved=1 & T1_achieved=0 ) ];

// (Bad) G1 is achieved while T1 or T2 is not achieved
P>0 [ F ( G1_achieved=1 & (T1_achieved=0 | T2_achieved=0) ) ];


//
// =============================================================
// COUNTEREXAMPLES: G2 OR REFINEMENT (G4 | G5)
// =============================================================

// (Bad) Both OR-children G4 and G5 pursued simultaneously
P>0 [ F ( G4_pursued=1 & G5_pursued=1 ) ];

// (Bad) G2 achieved without either child achieved
P>0 [ F ( G2_achieved=1 & G4_achieved=0 & G5_achieved=0 ) ];

// (Bad) It is impossible to ever pursue G4 (should NOT be the case)
// Good semantics expect reachability; this tests if G4 is unreachable:
P>=1 [ G (G4_pursued=0) ];

// (Bad) It is impossible to ever pursue G5 (should NOT be the case)
P>=1 [ G (G5_pursued=0) ];


//
// =============================================================
// COUNTEREXAMPLES: G3 AND T5
// =============================================================

// (Bad) G3 is achieved while T5 is not achieved
P>0 [ F ( G3_achieved=1 & T5_achieved=0 ) ];


//
// =============================================================
// COUNTEREXAMPLES: G4/G5 AND T3/T4
// =============================================================

// (Bad) G4 is achieved while T3 is not achieved
P>0 [ F ( G4_achieved=1 & T3_achieved=0 ) ];

// (Bad) G5 is achieved while T4 is not achieved
P>0 [ F ( G5_achieved=1 & T4_achieved=0 ) ];