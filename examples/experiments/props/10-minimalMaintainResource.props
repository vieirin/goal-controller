// ======================================================
// Basic sanity / reachability
// ======================================================

// Probability that the top-level goal G0 is eventually achieved
P=?  [ F G0_achieved=1 ];

// Probability that we eventually reach a state where the drone
// is in flight and the communication link is up at least once
P=?  [ F (inFlight & commLink) ];

// Sanity: the battery resource always stays within its declared bounds
P>=1 [ G (R0>=0 & R0<=5) ];


// ======================================================
// Sequential AND semantics
//   - G0: [G1; G2; G3; G4; G5]
//   - G14: [T10; T11]
// ======================================================

// --- G0: later subgoals are only pursued once previous ones are achieved ---

// G2 is only pursued after G1 is achieved
P>=1 [ G (G2_pursued=1 => G1_achieved=1) ];

// G3 is only pursued after G1 and G2 are achieved
P>=1 [ G (G3_pursued=1 => (G1_achieved=1 & G2_achieved=1)) ];

// G4 is only pursued after G1, G2 and G3 are achieved
P>=1 [ G (G4_pursued=1 => (G1_achieved=1 & G2_achieved=1 & G3_achieved=1)) ];

// G5 is only pursued after G1, G2, G3 and G4 are achieved
P>=1 [ G (G5_pursued=1 => (G1_achieved=1 & G2_achieved=1 & G3_achieved=1 & G4_achieved=1)) ];

// Optional: never pursue two top-level subgoals of G0 in parallel
P>=1 [ G !(
      (G1_pursued=1 & G2_pursued=1)
   |  (G2_pursued=1 & G3_pursued=1)
   |  (G3_pursued=1 & G4_pursued=1)
   |  (G4_pursued=1 & G5_pursued=1)
) ];

// --- G14: T10;T11 must be sequential and guarded by !hasMoreDelivery ---

// Whenever we *start* G14, hasMoreDelivery is false at that moment
filter(forall,
       P>=1 [ G true ],
       (G14_pursued=0 & G14_achieved=0) & hasMoreDelivery);

// T11 is only pursued after T10 has been achieved
P>=1 [ G (T11_pursued=1 => T10_achieved=1) ];



// ======================================================
// Interleaved AND semantics
//   - G1: [T1 # T2]
//   - G2: [G6 # G7] with assertion "missionReady"
// ======================================================

// --- G1: both T1 and T2 needed, order not fixed ---

// It is possible to pursue T1 first (before T2)
P>0  [ F (G1_pursued=1 & T1_pursued=1 & T2_pursued=0) ];

// It is possible to pursue T2 first (before T1)
P>0  [ F (G1_pursued=1 & T2_pursued=1 & T1_pursued=0) ];

// Assertion link: G2 can only start when missionReady holds
P>=1 [ G (G2_pursued=1 => missionReady) ];

// missionReady is only set after T1 is achieved (no spurious missionReady)
P>=1 [ G (missionReady => T1_achieved=1) ];

// --- G2: G6 and G7 are interleaved children ---

// It is possible to pursue G6 while G7 is not yet pursued
P>0  [ F (G2_pursued=1 & G6_pursued=1 & G7_pursued=0) ];

// It is possible to pursue G7 while G6 is not yet pursued
P>0  [ F (G2_pursued=1 & G7_pursued=1 & G6_pursued=0) ];


// When G2 is finally achieved, the intended logical conditions hold:
// G6 has been achieved and the maintain condition for G7 is satisfied
// Structural / achievement condition for G2:
P>=1 [ G (G2_achieved=1 => G6_achieved=1) ];


// ======================================================
// Choice semantics for G3: Configure Flight Profile [+]
// Branches: G9, G10, G11 with battery-dependent guards on R0
// ======================================================

// 1) Mutual exclusion: never pursue two profile goals in parallel
P>=1 [ G !(
      (G9_pursued=1 & G10_pursued=1)
   |  (G9_pursued=1 & G11_pursued=1)
   |  (G10_pursued=1 & G11_pursued=1)
) ];

// 2) When executing T5 (energy-saving profile), R0 must satisfy the guard (R0 <= 3)
P>=1 [ G (T5_pursued = 1 => R0 <= 3) ];

// 3) When executing T6 (balanced profile), R0 must satisfy the guard (R0 >= 3)
filter(forall,
       P<=0 [ X (T6_pursued=1) ],
       (T6_pursued=0 & T6_achieved=0 & R0<3));

// 4) When executing T7 (aggressive profile), R0 must satisfy the guard (R0 > 4)
P>=1 [ G (T7_pursued = 1 => R0 > 4) ];

// Each branch is actually reachable from the initial state
P>0  [ F (G3_pursued=1 & G9_pursued=1) ];
P>0  [ F (G3_pursued=1 & G10_pursued=1) ];
P>0  [ F (G3_pursued=1 & G11_pursued=1) ];


// ======================================================
// Degradation semantics
//   - G4: Maintain Safety Envelope [G12 @2 -> G13]
// ======================================================

// Degrade to G13 only after at least 2 failed attempts of G12
P>=1 [ G (G13_pursued=1 => G12_failed>=2) ];

// It is possible to succeed using only G12 (no degradation)
P>0  [ F (G4_achieved=1 & G12_achieved=1 & G13_achieved=0) ];

// It is possible to reach G4 by using the degraded mode G13
P>0  [ F (G4_achieved=1 & G13_achieved=1) ];


// ======================================================
// Alternative OR semantics
//   - G5: Standard Landing Delivery [G14 | G15]
//   - G14 guarded by !hasMoreDelivery
// ======================================================

// The two landing options are not pursued in parallel
P>=1 [ G !(G14_pursued=1 & G15_pursued=1) ];

// Guard for G14 (standard landing):
// From any state where G14 has not yet started and hasMoreDelivery is true,
// the probability to start G14 in the next step is 0.
filter(forall,
       P<=0 [ X (G14_pursued=1) ],
       (G14_pursued=0 & G14_achieved=0 & hasMoreDelivery));

// It is possible to satisfy G5 via G14
P>0  [ F (G5_achieved=1 & G14_achieved=1) ];

// It is possible to satisfy G5 via G15
P>0  [ F (G5_achieved=1 & G15_achieved=1) ];


// ======================================================
// Maintain semantics
//   - G7: Maintain communication link
//     assertion: inFlight
//     maintain:  commLink
// ======================================================

// Structural: G7 is only pursued when the drone is in flight
P>=1 [ G (G7_pursued=1 => inFlight) ];

// Structural: G7's "achieved_maintain" condition matches commLink
P>=1 [ G ( (G7_achieved_maintain & commLink)
        | (!G7_achieved_maintain & !commLink) ) ];

// Maintain objective (1): once the drone climbs to cruise altitude (inFlight),
// we eventually reach a state where commLink is true while still inFlight
P>=1 [ F (inFlight & commLink) ];

// Maintain: if communication fails while in flight,
// there must exist SOME path that recovers link or leaves flight.
filter(forall,
       P>0 [ F (commLink | !inFlight) ],
       inFlight & !commLink);


// ======================================================
// Resource usage sanity (battery R0 and delivery availability)
// ======================================================

// Battery never increases above its initial maximum (redundant but explicit)
P>=1 [ G (R0<=5) ];

// From the initial state, it is possible to consume battery
// (i.e., reach a state with R0<5)
P>0  [ F (R0<5) ];

// From the initial state, it is possible to reach a low-battery situation
// (R0 small enough that only conservative profiles are allowed)
P>0  [ F (R0<=3) ];

// From the initial state, it is possible to reach a state with hasMoreDelivery=true
// (standard landing G14 is disabled and emergency G15 remains possible)
P>0  [ F hasMoreDelivery ];